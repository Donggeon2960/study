### [문제 2 해결] BLDCM PI 제어 및 속도 검출 (40점)

#### (1) 속도를 검출하는 3가지 방법 원리 및 아두이노 구현 (20점)

**1. 속도 검출의 3가지 방법 및 원리**

일반적인 모터 제어 시스템에서 속도를 검출하는 3가지 방법은 다음과 같습니다.

1.  **M-method (펄스 카운트 방식):**

      * [cite_start]**원리:** 일정 시간(Sampling Time) 동안 엔코더나 홀센서에서 들어오는 **펄스의 개수(Pulse count)를 세어** 속도를 계산합니다[cite: 335].
      * [cite_start]**특징:** 고속 영역에서는 펄스가 많아 정밀하지만, 저속에서는 펄스 수가 적어 오차가 크고 속도 검출 지연이 발생합니다[cite: 338].
      * [cite_start]**식:** $RPM = \frac{120 \cdot Frequency}{P}$ (여기서 Frequency는 펄스 수 기반 계산)[cite: 337].

2.  **T-method (주기 측정 방식):**

      * [cite_start]**원리:** 펄스와 펄스 사이의 **시간(Period)을 측정**하여 주파수를 구하고 이를 통해 속도를 계산합니다[cite: 347].
      * **특징:** 저속 영역에서도 펄스 간격이 길어 시간을 정밀하게 측정할 수 있으므로 분해능이 좋고 응답성이 빠릅니다. [cite_start]아두이노와 같은 마이크로컨트롤러 환경에서 많이 사용됩니다 [cite: 350-354].
      * [cite_start]**식:** $Frequency = \frac{1}{Period}$, $RPM = \frac{120 \cdot Frequency}{P}$[cite: 354].

3.  **M/T-method (혼합 방식):**

      * **원리:** M법과 T법을 결합한 방식으로, 저속에서는 T법을, 고속에서는 M법을 사용하여 전 속도 영역에서 정밀도를 확보하는 방식입니다. (자료에는 M법과 T법이 주로 설명되어 있으나, 통상적인 제어 이론에서 3번째 방법으로 언급됨)

**2. 아두이노를 이용한 방법 및 구현 (T-method)**

제공된 자료와 코드에서 아두이노는 \*\*T-method (주기 측정 방식)\*\*을 사용합니다.

  * **선택 이유:** 홀센서 신호는 엔코더에 비해 분해능이 낮기 때문에, 펄스 수를 세는 M법보다는 펄스 사이의 시간을 마이크로초($\mu s$) 단위로 정밀하게 측정하는 T법이 더 적합합니다.
  * **구현 방법:**
    1.  [cite_start]**인터럽트 설정:** `attachInterrupt(0, function, RISING);`을 사용하여 홀센서 신호($H_A$)가 `LOW`에서 `HIGH`로 변할 때(RISING Edge)마다 인터럽트가 발생하도록 설정합니다[cite: 567].
    2.  [cite_start]**시간 측정 (`micros()`):** 인터럽트 서비스 루틴(`function`) 내부에서 `micros()` 함수를 호출하여 현재 시각(`current_time`)을 저장합니다[cite: 363].
    3.  [cite_start]**주기 계산:** `현재 시각 - 이전 시각`을 계산하여 펄스 주기(`period`)를 구합니다[cite: 364].
    4.  [cite_start]**RPM 변환:** 주기의 역수를 취해 주파수(`frequency`)를 구하고, 이를 RPM 공식에 대입하여 속도를 산출합니다[cite: 366].

-----

#### (2) PI 제어 식 유도 및 C 코드 구현 (20점)

**1. PI 제어 식 유도 (이산화 과정)**

연속 시간 영역의 PI 제어 식을 마이크로컨트롤러(C 코드)에서 사용하기 위해 이산형(Discrete) 증분식으로 변환하는 과정입니다. (자료 `아두이노 BLDC모터 구동1.pdf` 19페이지 참조)

1.  **연속 시간 PI 제어 식:**
    [cite_start]$$u(t) = K_p e(t) + K_i \int e(t) dt$$ [cite: 631]
2.  **이산 시간 표현 ($n$번째 샘플링):**
    $$u(n) = K_p e(n) + K_i \sum_{k=0}^{n} e(k) T_s$$
3.  **변화량(증분) 계산 ($\Delta u(n) = u(n) - u(n-1)$):**
    이전 스텝($n-1$)의 제어 입력을 현재 스텝에서 빼면, 적분항의 누적된 합을 없애고 현재의 변화분만 남길 수 있습니다.
    [cite_start]$$u(n) - u(n-1) = K_p \{e(n) - e(n-1)\} + K_i e(n) T_s$$ [cite: 636]
4.  **최종 제어 입력 식 (속도형 알고리즘):**
    [cite_start]$$u(n) = u(n-1) + \underbrace{K_p \{e(n) - e(n-1)\}}_{P\_term} + \underbrace{K_i \{e(n) T_s\}}_{I\_term}$$ [cite: 638-639]

이 식을 통해 적분 누적(Wind-up)을 방지하고 메모리 사용을 줄이는 코드를 구현할 수 있습니다.

**2. C 코드 구현**

문제에서 제시한 변수명(`err`, `pr_err`, `Kp`, `Ki`)을 사용하여 구현한 코드는 다음과 같습니다.

```c
// 변수 선언 (문제 조건 및 일반적인 자료형 가정)
float Kp = 0.15;      // 비례 이득
float Ki = 0.9;       // 적분 이득
float err;            // 현재 오차
float pr_err;         // 과거 오차 (previous error)
float p_term;         // 비례 제어항
float i_term;         // 적분 제어항
float pi_out;         // PI 제어 결과 (증분값)
float duty = 0;       // 현재 제어 출력 (PWM Duty)
float Ts = 0.001;     // 샘플링 주기 (예: 1ms)

// PI 제어 함수 (주기적으로 호출됨)
void PI_Control() {
    // 1. 현재 오차 계산 (목표값 - 현재값)
    // 예: err = target_rpm - current_rpm; (문제 조건에 따라 err는 이미 계산되었다고 가정 가능)

    // 2. 비례 제어항 계산 (Incremental Form: 오차의 변화량 이용)
    // 식: P = Kp * (e(n) - e(n-1))
    p_term = Kp * (err - pr_err);  [cite_start]// [cite: 641]

    // 3. 적분 제어항 계산
    // 식: I = Ki * e(n) * Ts
    i_term = Ki * err * Ts;        [cite_start]// [cite: 642]

    // 4. PI 제어 결과 (증분값) 계산
    pi_out = p_term + i_term;      [cite_start]// [cite: 643]

    // 5. 최종 제어 출력(Duty) 업데이트 (현재 Duty에 증분값을 더함)
    duty = duty + pi_out;          [cite_start]// [cite: 644]

    // 6. PWM 출력 제한 (Anti-windup 및 하드웨어 보호)
    if (duty > 255) duty = 255;
    if (duty < 0) duty = 0;

    // 7. 현재 오차를 과거 오차로 저장 (다음 루프를 위해)
    pr_err = err;                  [cite_start]// [cite: 616]
}
```

-----

**[답안 작성 팁]**

  * (1)번 문제에서 **T-method**를 선택한 이유로 "제공된 자료의 코드에서 `current_time - previous_time`을 통해 주기를 구하고 있기 때문"이라고 명시하면 출제 의도를 정확히 파악했음을 보여줄 수 있습니다.
  * (2)번 코드 구현 시, 단순히 `P = Kp * err`가 아니라 **`P = Kp * (err - pr_err)`** 형태로 작성하는 것이 중요합니다. 이는 자료(`아두이노 BLDC모터 구동1.pdf` 19p)에서 유도한 **증분형(Incremental) PI 제어식**을 따르는 것이며, `duty = duty + pi_out` 형태로 누적해주는 것이 핵심입니다.
