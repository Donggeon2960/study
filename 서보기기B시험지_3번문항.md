### [문제 3 해결] BLDCM PI 제어 및 속도 검출 (30점)

#### (1) 속도를 검출하는 3가지 방법 원리 및 아두이노 구현 (15점)

**1. 속도 검출의 3가지 방법 및 원리**

모터의 회전 속도를 검출하는 방식은 펄스(Pulse)를 어떻게 측정하느냐에 따라 크게 3가지로 나뉩니다.

1.  **M-method (펄스 계수 방식, Frequency Measurement):**

      * [cite_start]**원리:** 일정한 시간(Sampling Time, $T$) 동안 입력되는 펄스의 개수($m$)를 카운트하여 속도를 계산합니다[cite: 1179].
      * [cite_start]**특징:** 펄스 수가 많은 **고속 영역**에서 정밀도가 높으나, 저속에서는 펄스 수가 적어 오차가 크고 속도 검출 지연이 발생합니다[cite: 1182].
      * **식:** $N(rpm) = \frac{60 \cdot m}{P \cdot T}$ ($P$: 회전당 펄스 수).

2.  **T-method (주기 측정 방식, Period Measurement):**

      * [cite_start]**원리:** 펄스와 펄스 사이의 \*\*시간 주기(Period, $t$)\*\*를 고속의 클럭으로 측정하여 속도를 계산합니다[cite: 1191].
      * **특징:** 펄스 간격이 긴 **저속 영역**에서도 정밀한 측정이 가능하며 응답성이 빠릅니다. 엔코더 분해능이 낮은 홀센서 제어에 적합합니다.
      * **식:** $N(rpm) = \frac{60}{P \cdot t}$ ($t$: 측정된 주기).

3.  **M/T-method (혼합 방식):**

      * **원리:** M법과 T법을 결합한 방식으로, 일정 시간 동안의 펄스 개수($m$)와 그 펄스들이 발생한 정확한 시간($t$)을 동시에 측정합니다.
      * **특징:** 저속과 고속 전 영역에서 높은 정밀도를 가집니다.

**2. 아두이노를 이용한 방법 및 구현 (T-method)**

제공된 자료와 아두이노 코드에서는 \*\*T-method (주기 측정 방식)\*\*을 사용합니다.

  * **선택 이유:** BLDC 모터의 홀센서는 엔코더에 비해 분해능(Resolution)이 낮기 때문에, 펄스 개수를 세는 M법보다는 펄스 사이의 시간을 마이크로초($\mu s$) 단위로 정밀하게 측정하는 T법이 제어 응답성을 높이는 데 유리합니다.
  * **구현 방법:**
    1.  [cite_start]**인터럽트 설정:** `attachInterrupt(0, function, RISING);`을 사용하여 홀센서 A($H_a$) 신호가 `RISING` Edge일 때마다 함수가 호출되도록 합니다[cite: 1411].
    2.  [cite_start]**시간 측정 (`micros()`):** 인터럽트 함수 내에서 `micros()`를 호출하여 현재 시각(`current_time`)을 저장합니다[cite: 1445].
    3.  [cite_start]**주기 계산 (`Period`):** `현재 시각 - 이전 시각`을 계산하여 펄스 주기(`period`)를 구합니다[cite: 1446].
    4.  [cite_start]**속도 환산:** 주기의 역수를 취해 주파수(`frequency`)를 구하고, 이를 RPM 공식($rpm = \frac{120 \cdot f}{P}$)에 대입합니다[cite: 1451, 1453].

-----

#### (2) PI 제어 식 유도 및 C 코드 구현 (15점)

**1. PI 제어 식 유도 (증분형 알고리즘, Incremental Form)**

마이크로컨트롤러 구현을 위해 연속 시간 PI 제어식을 이산 시간(Discrete Time)의 증분형 식으로 변환합니다. (자료 `아두이노 BLDC모터 구동1.pdf` 19페이지 참조)

1.  **연속 시간 PI 제어 식:**
    [cite_start]$$u(t) = K_p e(t) + K_i \int e(t) dt$$ [cite: 1475]
2.  **이산 시간 표현 ($n$번째 샘플링):**
    $$u(n) = K_p e(n) + K_i \sum_{k=0}^{n} e(k) T_s$$
3.  **변화량(증분) 계산 ($\Delta u(n) = u(n) - u(n-1)$):**
    현재 스텝($n$)의 제어량에서 이전 스텝($n-1$)의 제어량을 뺍니다. 이 과정에서 적분항($\sum$)이 소거되고 현재의 오차항만 남습니다.
    [cite_start]$$u(n) - u(n-1) = K_p \{e(n) - e(n-1)\} + K_i e(n) T_s$$ [cite: 1480, 1483]
4.  **최종 C 코드 구현용 식:**
    [cite_start]$$u(n) = u(n-1) + \underbrace{K_p \{e(n) - e(n-1)\}}_{P_{val}} + \underbrace{K_i \{e(n) T_s\}}_{I_{val}}$$ [cite: 1483]

**2. C 코드 구현**

문제에서 제시한 변수(`err`, `pr_err`, `Kp`, `Ki`)를 사용하여 위 유도 식을 코드로 구현합니다. (자료의 `switching` 함수 로직 반영)

```c
// 변수 선언 (전역 변수 가정)
float Kp = 0.15;      // 비례 이득
float Ki = 0.9;       // 적분 이득 (Ts가 포함된 값으로 가정하거나 별도 곱함)
float err;            // 현재 오차 (목표값 - 현재값)
float pr_err;         // 과거 오차 (previous error)
float duty = 0;       // 제어 출력값 (PWM Duty)
float P_val, I_val;   // 비례항, 적분항 계산 변수
float PI_out;         // PI 제어 증분 결과

// PI 제어 함수 (주기적으로 실행, 예: 1ms)
void PI_Control() {
    // 1. 비례 제어항 (Incremental Form: 오차의 변화량 이용)
    // 식: P = Kp * (현재오차 - 과거오차)
    P_val = Kp * (err - pr_err);   [cite_start]// [cite: 1463, 1485]

    // 2. 적분 제어항
    // 식: I = Ki * 현재오차 (Ts는 Ki에 포함되거나 상수로 곱해짐)
    I_val = Ki * err;              [cite_start]// [cite: 1467, 1486]

    // 3. PI 제어 결과 (증분값) 합산
    PI_out = P_val + I_val;        [cite_start]// [cite: 1469, 1487]

    // 4. 최종 제어 출력(Duty) 누적 업데이트
    // u(n) = u(n-1) + Δu
    duty = duty + PI_out;          [cite_start]// [cite: 1471, 1488]

    // 5. Anti-windup 및 PWM 범위 제한 (0 ~ 255)
    if (duty > 255) duty = 255;
    else if (duty < 0) duty = 0;   [cite_start]// [cite: 1472]

    // 6. 다음 루프를 위해 현재 오차를 과거 오차로 저장
    pr_err = err;                  [cite_start]// [cite: 1460]
}
```

-----

**[답안 작성 팁]**

  * (1)번 문제의 아두이노 구현 설명 시, `attachInterrupt`, `micros`, `current_time - previous_time`과 같은 키워드를 포함하면 제공된 자료를 충실히 학습했음을 보여줄 수 있습니다.
  * (2)번 코드에서 `duty = Kp*err + ...` 가 아니라 **`duty = duty + ...`** 형태로 \*\*누적(Accumulation)\*\*하는 것이 핵심입니다. 이는 자료에서 유도한 '속도형(Velocity form) 알고리즘'의 특징이며, 이를 통해 적분 윈드업(Wind-up)을 방지하고 메모리 효율을 높일 수 있다는 점을 강조하면 좋습니다.
