<div align="center">
  <h1>BLDCM 구동 장치 제작 보고서</h1>
</div>

<br>

<div align="right">
  20210705 김동건
</div>

<br>

-----

# BLDC 모터 구동 장치 제작 보고서

## 1\. BLDCM 구동 원리

### 1.1 BLDC 모터의 기본 구조

BLDC 모터는 기계적인 브러시와 정류자가 없는 직류 전동기입니다. 기존 DC 모터가 브러시를 통해 기계적으로 전류의 방향을 바꾸는 것과 달리, BLDC 모터는 반도체 소자(트랜지스터 등)를 이용하여 전기적으로 전류의 방향을 제어합니다.

  * **회전자(Rotor):** 영구자석으로 구성되어 있으며 회전하는 부분입니다.
  * **고정자(Stator):** 권선(Coil)이 감겨 있어 자계를 형성하는 부분입니다.
  * **위치 센서:** 회전자의 자극 위치를 검출하기 위해 주로 홀 센서(Hall Sensor)를 사용합니다.

### 1.2 6-Step 구동 (120도 통전 방식)

BLDC 모터의 가장 일반적인 구동 방식은 3상 권선에 120도 위상차를 두고 전류를 흘려주는 6-Step 구동 방식입니다.

1.  **홀 센서 신호:** 3개의 홀 센서($H_a, H_b, H_c$)가 회전자의 N극과 S극을 감지하여 디지털 신호(High/Low)를 출력합니다.
2.  **스위칭 시퀀스:** 홀 센서의 신호 조합(State)에 따라 3상 인버터의 6개 스위치 중 2개(상단 1개, 하단 1개)를 켭니다. 이를 통해 고정자에 회전 자계가 형성되어 회전자를 끌어당기거나 밀어내며 회전력을 발생시킵니다.
3.  **전류의 흐름:** 예를 들어 A상 상단 스위치와 B상 하단 스위치가 켜지면 전류는 A상 권선으로 들어가 B상 권선으로 나옵니다.

-----

## 2\. 아두이노를 이용한 BLDCM 구동

### 2.1 하드웨어 구성 및 회로도

아두이노를 컨트롤러로 사용하여 3상 인버터 회로를 구성합니다. 제공된 자료에 따른 회로 구성은 다음과 같습니다.

  * **MCU:** Arduino Uno.
  * **3상 인버터:**
      * **High-Side (상단 스위치):** TIP115 (PNP Darlington Transistor) 사용. PNP 타입이므로 Base가 Low일 때 켜집니다.
      * **Low-Side (하단 스위치):** IRF530 (N-Channel MOSFET) 사용. Gate가 High일 때 켜집니다.
      * **Pre-Driver:** 아두이노의 5V 신호로 TIP115(12V\~24V 라인)를 제어하기 위해 트랜지스터를 전단에 배치하여 레벨 시프팅 및 스위칭을 담당합니다.
  * **홀 센서 입력:** 모터 내부의 홀 센서($H_a, H_b, H_c$) 출력을 아두이노의 디지털 핀(2, 4, 7번 등)에 연결하며, 풀업(Pull-up) 저항을 사용하여 신호를 안정화합니다.

### 2.2 구동 알고리즘

아두이노는 홀 센서의 값을 읽어 현재 회전자의 위치(Sector)를 파악하고, 그에 맞는 상(Phase)에 전압을 인가합니다.

  * **상태 변환:** 3개의 홀 센서 값을 이진수로 조합하여 하나의 상태 값(State)으로 변환합니다.
    $$State = 4 \times H_a + 2 \times H_b + 1 \times H_c$$.
  * **스위칭 테이블:** 계산된 State에 따라 미리 정의된 스위칭 테이블대로 핀 출력을 제어합니다. 예를 들어 `State == 5` ($H_a=1, H_b=0, H_c=1$)인 경우, $S_A^+$ (상단)와 $S_B^-$ (하단) 스위치를 켭니다.

-----

## 3\. PI 제어 및 전체 코드 설명

### 3.1 PI 제어 원리

모터의 속도를 일정하게 유지하거나 목표 속도에 도달하게 하기 위해 PI(비례-적분) 제어를 사용합니다.

  * **속도 측정 (T-method):** 홀 센서 신호의 Rising Edge 사이의 시간(주기, Period)을 측정하여 RPM을 계산합니다. 저속에서도 정밀한 측정이 가능합니다.
    
  * **오차(Error) 계산:** $$Error = \text{Target RPM} - \text{Current RPM}$$
  * **PI 연산:**
      * **P(비례) 제어:** 현재 오차에 비례하여 제어량을 조절합니다. $$P = K_p \times Error$$.
      * **I(적분) 제어:** 오차의 누적값을 통해 잔류 편차(Steady-state error)를 제거합니다. $$I = I + (Error \times K_i \times dt)$$.
  * **출력(PWM Duty):** 최종적으로 계산된 PI 값을 현재의 PWM Duty Cycle에 더하여 모터 전압을 조절합니다.

### 3.2 전체 코드 (Markdown)

```cpp
/*
 * BLDC Motor Control with Arduino
 * Features: 6-Step Commutation, PI Speed Control, Serial Plotting
 * Based on SEMIC Lab References
 */

[cite_start]// 핀 번호 정의 [cite: 5724-5741]
// Hall Sensors
const int hall1 = 2; // Ha (Interrupt 0)
const int hall2 = 4; // Hb
const int hall3 = 7; // Hc (자료에 따라 6 또는 7, 회로도 기준 7로 설정)

// Driver Output Pins (High-Side & Low-Side)
const int SAM = 6;  // SA- (Low Side A)
const int SAP = 8;  // SA+ (High Side A)
const int SCM = 11; // SC- (Low Side C)
const int SBP = 12; // SB+ (High Side B)
const int SCP = 13; // SC+ (High Side C)
const int SBM = 5;  // SB- (Low Side B) - PWM 가능 핀 사용 권장

[cite_start]// 변수 선언 [cite: 5764-5811]
volatile unsigned long current_time, previous_time;
volatile float period = 0;
float frequency;
float rpm = 0, avr_rpm = 0;
int hall1_state, hall2_state, hall3_state;
int state;

// PI 제어 변수
float kp = 0.2428;   [cite_start]// P gain [cite: 6594]
float ki = 0.0025;   [cite_start]// I gain [cite: 6594]
int sensor_value;    // 가변저항 값 (목표 RPM 설정용)
float goal_rpm;      // 목표 RPM
float error, last_error = 0;
float p, i = 0, pi_val;
float duty = 50;     // 초기 PWM Duty

// 타이머 인터럽트 관련 변수
unsigned long timeout, while_period;

[cite_start]// PI 제어 클래스 (자료의 구조체/클래스 개념 반영) [cite: 6201]
class Control {
  public:
    float PI_control(float error, float last_error, float dt_sec) {
        float P_term = error * kp;
        // 적분항 누적 (Anti-windup 로직 포함 가능)
        i += error * ki * dt_sec; 
        
        [cite_start]// 적분항 제한 (예시) [cite: 6222]
        if (i > 10) i = 10;
        if (i < -10) i = -10;
        
        return P_term + i;
    }
};

Control mpi;

void setup() {
  [cite_start]// 시리얼 통신 초기화 [cite: 5744]
  Serial.begin(2000000); 

  [cite_start]// 핀 모드 설정 [cite: 5745-5754]
  pinMode(hall1, INPUT);
  pinMode(hall2, INPUT);
  pinMode(hall3, INPUT);
  
  pinMode(SAM, OUTPUT); pinMode(SAP, OUTPUT);
  pinMode(SBM, OUTPUT); pinMode(SBP, OUTPUT);
  pinMode(SCM, OUTPUT); pinMode(SCP, OUTPUT);
  
  // 가변저항 입력
  pinMode(A0, INPUT);

  [cite_start]// 외부 인터럽트 설정 (RPM 측정 및 초기 구동용) [cite: 5743]
  // Hall A의 Rising Edge에서 'function' 함수 호출
  attachInterrupt(digitalPinToInterrupt(hall1), function, RISING);

  [cite_start]// 타이머 인터럽트 설정 (Register Direct Access) [cite: 6307-6312]
  // 16MHz / 64 prescaler / 50 counts = 200us period
  noInterrupts();
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;
  OCR1A = 50; // Compare Match 값 설정 (약 200us)
  TCCR1B |= (1 << WGM12); // CTC 모드
  TCCR1B |= (1 << CS11) | (1 << CS10); // 64 분주
  TIMSK1 |= (1 << OCIE1A); // Timer1 Compare Match Interrupt Enable
  interrupts();
}

void loop() {
  [cite_start]// 시리얼 플로팅을 위한 데이터 출력 (30ms 주기) [cite: 6476-6481]
  static unsigned long a = 0, b = 0;
  a = millis();
  if (a - b >= 30) {
    Serial.println(avr_rpm); // 또는 rpm
    b = a;
  }
}

[cite_start]// RPM 측정 함수 (외부 인터럽트) [cite: 6426]
void function() {
  unsigned long now = micros();
  
  [cite_start]// 디바운싱: 너무 짧은 시간 내의 인터럽트는 무시 [cite: 6428]
  if (now - previous_time > 1000) { 
    period = now - previous_time;
    previous_time = now;
    
    // RPM 계산 (T-method)
    // frequency = 1,000,000 / period (us)
    [cite_start]// RPM = 120 * freq / poles (4극 기준) -> 30 * freq [cite: 6431-6432]
    frequency = 1000000.0 / period;
    rpm = 30 * frequency;
    
    [cite_start]// 이동 평균 필터 (노이즈 제거) [cite: 6433]
    avr_rpm = (avr_rpm * 0.9) + (rpm * 0.1);
  }
}

[cite_start]// 타이머 인터럽트 서비스 루틴 (Commutation & PI Control) [cite: 6492]
ISR(TIMER1_COMPA_vect) {
  [cite_start]// 1. 홀 센서 상태 읽기 [cite: 6523]
  hall1_state = digitalRead(hall1);
  hall2_state = digitalRead(hall2);
  hall3_state = digitalRead(hall3);
  
  [cite_start]// 2. 상태 계산 (2진수 가중치 합) [cite: 5429]
  state = (4 * hall1_state) + (2 * hall2_state) + (1 * hall3_state);

  [cite_start]// 3. PI 제어 수행 (목표 속도 추종) [cite: 6434-6436]
  sensor_value = analogRead(A0);
  goal_rpm = map(sensor_value, 0, 1023, 600, 1400); // 목표 RPM 매핑
  
  error = goal_rpm - rpm;
  
  // PI 제어값 계산 (dt는 타이머 주기인 0.0002초로 가정하거나 측정값 사용)
  float control_val = mpi.PI_control(error, last_error, 0.0002);
  last_error = error;
  
  // Duty Cycle 업데이트
  duty += control_val;
  
  [cite_start]// Duty 값 제한 (0 ~ 255) [cite: 6526]
  if (duty > 255) duty = 255;
  if (duty < 0) duty = 0;

  [cite_start]// 4. 스위칭 로직 (Commutation) [cite: 5432-5563]
  // 반시계 방향(CCW) 기준 로직 예시 (SA, SB, SC High side는 PWM 제어 가능)
  // analogWrite는 PWM핀에서만 작동하므로 회로 연결에 따라 High/Low Side 중 PWM 핀을 선택하여 duty 인가
  
  switch (state) {
    case 5: // Ha=1, Hb=0, Hc=1 -> A상 High, B상 Low
      analogWrite(SAP, (int)duty); digitalWrite(SAM, LOW);
      digitalWrite(SBP, LOW);      digitalWrite(SBM, HIGH);
      digitalWrite(SCP, LOW);      digitalWrite(SCM, LOW);
      break;
      
    [cite_start]case 1: // Ha=0, Hb=0, Hc=1 -> A상 High, C상 Low [cite: 5549]
      analogWrite(SAP, (int)duty); digitalWrite(SAM, LOW);
      digitalWrite(SBP, LOW);      digitalWrite(SBM, LOW);
      digitalWrite(SCP, LOW);      digitalWrite(SCM, HIGH);
      break;
      
    [cite_start]case 3: // Ha=0, Hb=1, Hc=1 -> B상 High, C상 Low [cite: 5522]
      digitalWrite(SAP, LOW);      digitalWrite(SAM, LOW);
      analogWrite(SBP, (int)duty); digitalWrite(SBM, LOW);
      digitalWrite(SCP, LOW);      digitalWrite(SCM, HIGH);
      break;
      
    [cite_start]case 2: // Ha=0, Hb=1, Hc=0 -> B상 High, A상 Low [cite: 5493]
      digitalWrite(SAP, LOW);      digitalWrite(SAM, HIGH);
      analogWrite(SBP, (int)duty); digitalWrite(SBM, LOW);
      digitalWrite(SCP, LOW);      digitalWrite(SCM, LOW);
      break;
      
    [cite_start]case 6: // Ha=1, Hb=1, Hc=0 -> C상 High, A상 Low [cite: 5474]
      digitalWrite(SAP, LOW);      digitalWrite(SAM, HIGH);
      digitalWrite(SBP, LOW);      digitalWrite(SBM, LOW);
      analogWrite(SCP, (int)duty); digitalWrite(SCM, LOW);
      break;
      
    [cite_start]case 4: // Ha=1, Hb=0, Hc=0 -> C상 High, B상 Low [cite: 5454]
      digitalWrite(SAP, LOW);      digitalWrite(SAM, LOW);
      digitalWrite(SBP, LOW);      digitalWrite(SBM, HIGH);
      analogWrite(SCP, (int)duty); digitalWrite(SCM, LOW);
      break;
      
    default: // 그 외의 경우 정지
      digitalWrite(SAP, LOW); digitalWrite(SAM, LOW);
      digitalWrite(SBP, LOW); digitalWrite(SBM, LOW);
      digitalWrite(SCP, LOW); digitalWrite(SCM, LOW);
      break;
  }
}
```

### 3.3 코드 상세 설명

1.  **초기화 (`setup`)**: `attachInterrupt`를 사용하여 홀 센서 A의 신호 변화(Rising Edge)를 감지합니다. 또한, 정밀한 제어 루프를 위해 아두이노의 Timer1 레지스터를 직접 조작하여 200us마다 인터럽트가 발생하도록 설정합니다.
2.  **속도 측정 (`function`)**: 홀 센서 인터럽트가 발생할 때마다 현재 시간(`micros()`)을 측정하고 이전 시간과의 차이(주기)를 구합니다. 이 주기의 역수를 취해 주파수를 구하고, 이를 RPM으로 변환합니다.
3.  **PI 제어 및 스위칭 (`ISR`)**:
      * **상태 판별:** 3개의 홀 센서 값을 읽어 1\~6 사이의 State 값을 만듭니다.
      * **PI 연산:** 가변저항으로 설정한 목표 RPM과 현재 RPM의 차이(Error)를 구하고, P게인과 I게인을 적용하여 모터에 인가할 전압 비율(Duty Cycle)을 계산합니다.
      * **전자적 정류(Commutation):** 계산된 State 값에 따라 `switch-case` 문을 사용하여 3상 인버터의 TR을 켭니다. 속도 조절을 위해 High-Side 트랜지스터 핀에는 `analogWrite`로 PWM 신호(Duty)를 내보냅니다.
